\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{ulem}
\usepackage[russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\thispagestyle{empty}
\begin{center}
    {\Large Московский авиационный институт\\ (национальный исследовательский университет)}

    \vspace{48pt}

    {\large Факультет информационных технологий и прикладной математики}

    \vspace{36pt}

    {\large Кафедра вычислительной математики и~программирования}

    \vspace{48pt}
    
    Лабораторная работа \textnumero 8 по курсу \enquote{Дискретный анализ}

\end{center}
    
    \vspace{72pt}
    
    \begin{flushright}
    \begin{tabular}{rl}
    Студент: & А.\,Н. Марков \\
    Преподаватель: & Н.\,А. Зацепин \\
    Группа: & М8О-308Б \\
    Дата: & \\
    Оценка: & \\
    Подпись: & \\
    \end{tabular}
    \end{flushright}
    
    \vfill
    
    \begin{center}
    \bfseries
    Москва, \the\year
\end{center}

\newpage

\subsection*{Условие}
\begin{enumerate}
\item Общая постановка задачи 

Разработать жадный алгоритм решения задачи, определяемой своим вариантом. Доказать его корректность, оценить скорость и объём затрачиваемой оперативной памяти.

Реализовать программу на языке С или С++, соответсвующую построенному алгоритму. Формат входных и выходных данных описан в варианте задания.

\item Вариант задания 

Вариант 5. Дана последовательность длины N из целых чисел 1, 2, 3. Необходимо найти минимальное количество обменов элементов последовательности, в результате которых последовательность стала бы отсортированной.

\item Формат входных данных

Число N на первой строке и N чисел на второй строке.

\item Формат результата

Минимальное количество обменов.

\end{enumerate}

\subsection*{Метод решения}

В жадном алгоритме всегда делается выбор, который кажется самым лучшим в данный момент, т.е. выполняется локально оптимальный выбор, который в конечном итоге приведет к оптимальному решению глобальной задачи.

Алгоритм решения моей задачи: при считывании последовательности будем подсчитывать количество единиц count1 и двоек count2, чтобы сначала расставить единички, а затем двойки на нужные места. Затем будем пробегать с начала последовательности. Первые count1 итераций будем обменивать двойки/тройки с единицами. 

\begin{itemize}
    \item Если обменивается двойка, то будем искать первую встретившуюся единицу, начиная с count1-го индекса последовательности. Как только найдем единицу, обмениваем ее с двойкой. 
    \item Если обменивается тройка, то аналогично с обменом двойки ищем единицу, но теперь с начиная с правого конца последовательности. Это нужно для того, чтобы тройка не занимала место для двоек, тем самым игнорируются лишние обмены.
\end{itemize}

Таким образом все count1 единиц будут занимать позиции от 0 до $count1 - 1$, 
а оставшаяся часть последовательности будет состоять только из двоек и троек.

Затем будем рассматривать последовательность [count1, count1 + count2 - 1]. В этой области должны находиться count2 двоек, поэтому нам потребуется только count2 итераций, чтобы обменять тройки в этой области на двойки, находящиеся вне этой области. 

После того, как все count2 двоек встанут на свои места, алгоритм завершается, поскольку оставшиеся N - count1 - count2 элементов будут являться тройками, находящимися на правильных местах.

Временная сложность алгоритма $O(N^2)$. Сложность по памяти $O(N)$.

\subsection*{Описание программы}

Программа состоит из одного файла main.cpp, в котором находится реализация алгоритма.
\subsection*{Дневник отладки}

Программа зашла на чекер с первой попытки.

\subsection*{Тест производительности}

Тесты создавались с помощью небольших программы generator.py. Создавались последовательности из N символов.

\begin{tikzpicture}
	\begin{axis}[ylabel=Время в мкс,xlabel=Количество чисел в последовательности, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
	    ( 15000, 27489 )
	    ( 10000, 12301 )
	    ( 7500, 7344 )
	    ( 5000, 3967 )
	    ( 4000, 2733 )
	    ( 3000, 2252 )
	    ( 2000, 1731 )
		( 1000, 596 )};
	\end{axis}

\end{tikzpicture}

\subsection*{Выводы}

Жадное программирование удобно в задачах, в которых на каждом шаге нужно делать локально наилучший выбор в надежде, что итоговое решение будет оптимальным.

Разница между динамическим программированием и жадными алгоритмами заключается в том, что в динамическом программировании нужно рассматривать несколько решений в поисках оптимального, а в жадных алгоритмах будет только одно предположительно оптимальное решение. Однако такая простота применения в сложных задачах выливается в сложное доказательство применимости жадного алгоритма для ее решения.

\end{document}